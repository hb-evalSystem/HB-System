# ================================================================
#  open_core/agent_loop.py
#  Lightweight Execution Loop for Open-Core Agent
# ================================================================

from dataclasses import dataclass
from typing import Optional

from adapt_planner import AdaptPlan, Plan
from edm_memory import EDM
from external_llm_api import llm_call


# ================================================================
# 1. Loop State Structure
# ================================================================

@dataclass
class LoopState:
    """
    Represents the runtime execution state of the agent loop.
    Tracks the active plan, step progression, and last output.
    """
    goal: str
    plan: Optional[Plan] = None
    step_index: int = 0
    finished: bool = False
    last_output: str = ""


# ================================================================
# 2. Agent Execution Loop
# ================================================================

class AgentLoop:
    """
    Executes plans generated by AdaptPlan step-by-step.
    Integrates with an external LLM API for performing each step.
    """

    def __init__(self, edm: EDM, planner: AdaptPlan):
        self.edm = edm
        self.planner = planner

    def run(self, goal: str) -> str:
        """
        Execute all steps of a plan for a given goal.
        Returns the last produced output.
        """

        # ------------------------------------------------------------
        # Step 1: Initialize loop state and generate plan
        # ------------------------------------------------------------
        state = LoopState(goal=goal)
        state.plan = self.planner.generate_plan(goal, self.edm)

        print(f"--- Starting Open-Core Agent for: {goal} ---")

        # ------------------------------------------------------------
        # Step 2: Iterate through plan sub-goals
        # ------------------------------------------------------------
        while not state.finished:

            # Termination condition: no plan or all steps finished
            if state.plan is None or state.step_index >= len(state.plan.sub_goals):
                state.finished = True
                break

            # Fetch current step
            step = state.plan.sub_goals[state.step_index]
            print(f"\n[STEP {state.step_index + 1}] Executing: {step}")

            # Construct LLM execution prompt
            prompt = (
                f"Execute the following step:\n"
                f"Goal: {goal}\n"
                f"Step: {step}"
            )

            # External LLM execution
            output = llm_call(prompt)
            print(f"[OUTPUT]: {output}")

            # Update runtime state
            state.last_output = output
            state.step_index += 1

        # ------------------------------------------------------------
        # Step 3: Loop completion
        # ------------------------------------------------------------
        print("--- Open-Core Agent Finished ---")
        return state.last_output
